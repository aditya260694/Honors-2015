#-----------------------------------------------------------------
# pycparser: cdecl.py
#
# Example of the CDECL tool using pycparser. CDECL "explains"
# C type declarations in plain English.
#
# The AST generated by pycparser from the given declaration is
# traversed recursively to build the explanation.
# Note that the declaration must be a valid external declaration
# in C. All the types used in it must be defined with typedef,
# or parsing will fail. The definition can be arbitrary, it isn't
# really used - by pycparser must know which tokens are types.
#
# For example:
#
# 'typedef int Node; const Node* (*ar)[10];'
# =>
# ar is a pointer to array[10] of pointer to const Node
#
# Copyright (C) 2008-2011, Eli Bendersky
# License: BSD
#-----------------------------------------------------------------
import sys

# This is not required if you've installed pycparser into
# your site-packages/ with setup.py
#
sys.path.extend(['.', '..'])

from pycparser import c_parser, c_ast


def explain_c_declaration(c_decl):
    """ Parses the declaration in c_decl and returns a text 
        explanation as a string.
        
        The last external node of the string is used, to allow
        earlier typedefs for used types.
    """
    parser = c_parser.CParser()
    
    try:
        node = parser.parse(c_decl, filename='<stdin>')
    except c_parser.ParseError:
        e = sys.exc_info()[1]
        return "Parse error:" + str(e)

    if (    not isinstance(node, c_ast.FileAST) or 
            not isinstance(node.ext[-1], c_ast.Decl)):
        return "Not a valid declaration"

    return _explain_decl_node(node.ext[-1])


def _explain_decl_node(decl_node):
    """ Receives a c_ast.Decl note and returns its explanation in
        English.
    """
    #~ print decl_node.show()
    storage = ' '.join(decl_node.storage) + ' ' if decl_node.storage else ''
        
    return (decl_node.name + 
            " is a " + 
            storage + 
            _explain_type(decl_node.type))


def _explain_type(decl):
    """ Recursively explains a type decl node
    """
    typ = type(decl)
    
    if typ == c_ast.TypeDecl:
        quals = ' '.join(decl.quals) + ' ' if decl.quals else ''
        return quals + str(_explain_type(decl.type))

    elif typ == c_ast.Typename:
        return _explain_type(decl.type)
   
    elif typ == c_ast.Decl:
        return _explain_type(decl.type)
    		

    elif typ == c_ast.IdentifierType:
        return ' '.join(decl.names)

    elif typ == c_ast.PtrDecl:
        quals = ' '.join(decl.quals) + ' ' if decl.quals else ''
        return quals + 'pointer to ' + str(_explain_type(decl.type))

    elif typ == c_ast.ArrayDecl:
        arr = 'array'
        if decl.dim: arr += '[%s]' % decl.dim.value
        
        return arr + " of " + str(_explain_type(decl.type))
        
    		
    elif typ == c_ast.FuncDecl:
    	if decl.args:
            params = [_explain_type(param) for param in decl.args.params]
            args = ', '.join(params)
        else:
            args = ''
        return ('function(%s) returning ' % (args) + str(_explain_type(decl.type)))

    elif typ == c_ast.FuncDef:
    	return decl.decl.name
	
    elif typ == c_ast.Struct:
    	return 'struct ' + decl.name


def recurse_type(Node):
	typ = type(Node)
	#print('%s' % typ)
	return_list = []
	if typ == c_ast.TypeDecl:
		return_list.append(_explain_type(Node))

	

	elif typ == c_ast.Assignment:
		return_list+=recurse_type(Node.lvalue)
		return_list+=recurse_type(Node.rvalue)
		

	elif typ == c_ast.BinaryOp:
		return_list+=recurse_type(Node.left)
		return_list+=recurse_type(Node.right)
	
	elif typ == c_ast.Case:
		return_list+=recurse_type(Node.expr)
		for i in Node.stmts:
			return_list+=recurse_type(i)

	elif typ == c_ast.Cast:
		return_list+=recurse_type(Node.to_type)
		return_list+=recurse_type(Node.expr)
		


	elif typ == c_ast.Compound:
		for i in Node.block_items:
			return_list+=recurse_type(i)

	elif typ == c_ast.CompoundLiteral:
		return_list+=recurse_type(Node.type)
		return_list+=recurse_type(Node.init)

	elif typ == c_ast.Decl:
		return_list+=recurse_type(Node.type)
		return_list+=recurse_type(Node.init)
		return_list+=recurse_type(Node.bitsize)
		



	elif typ == c_ast.DeclList:
		for i in Node.decls:
			return_list+=recurse_type(i)

	elif typ == c_ast.Default:
		for i in Node.stmts:
			return_list+=recurse_type(i)

	elif typ == c_ast.DoWhile:
		return_list+=recurse_type(Node.cond)
		return_list+=recurse_type(Node.stmt)
		
	elif typ == c_ast.Enum:
		return_list+=recurse_type(Node.values)

	elif typ == c_ast.Enumerator:
		return_list+=recurse_type(Node.value)

	elif typ == c_ast.EnumeratorList:
		for i in Node.enumerators:
			return_list+=recurse_type(i)

	elif typ == c_ast.ExprList:
		for i in Node.exprs:
			return_list+=recurse_type(i)
	
	elif typ == c_ast.FileAST:
		for i in Node.ext:
			return_list+=recurse_type(i)
		
	
	elif typ == c_ast.For:
		return_list+=recurse_type(Node.init)
		return_list+=recurse_type(Node.cond)
		return_list+=recurse_type(Node.next)
		return_list+=recurse_type(Node.stmt)
		


	elif typ == c_ast.FuncCall:
		f = Node.name.name + "("
		for i in recurse_type(Node.args):
			f = f + i
		f = f + ")"
		return_list.append(f)
		return_list+=recurse_type(Node.args)
		return_list+=recurse_type(Node.name)
		

	elif typ == c_ast.FuncDecl:
		return_list+=recurse_type(Node.args)
		return_list+=recurse_type(Node.type)
	
	elif typ == c_ast.FuncDef:
		return_list+=recurse_type(Node.decl)
		return_list+=recurse_type(Node.body)

		if Node.param_decls != None:
			for i in Node.param_decls:
				return_list+=recurse_type(i)
		
		

	elif typ == c_ast.If:
		return_list+=recurse_type(Node.cond)
		return_list+=recurse_type(Node.iftrue)
		return_list+=recurse_type(Node.iffalse)
	
	elif typ == c_ast.InitList:
		for i in Node.exprs:
			return_list+=recurse_type(i)

	elif typ == c_ast.IdentifierType:
		return_list.append(_explain_type(Node))

	elif typ == c_ast.Label:
		return_list+=recurse_type(Node.stmt)
		
	elif typ == c_ast.NamedInitializer:
		return_list+=recurse_type(Node.expr)
		for i in Node.name:
			return_list+=recurse_type(i)
		

	elif typ == c_ast.ParamList:
		for i in Node.params:
			return_list+=recurse_type(i)


	elif typ == c_ast.PtrDecl:
		x = recurse_type(Node.type)		
		#for i in range(len(x)):
		#	x[i] = x[i]+" *"
		return_list+=x
		
	elif typ == c_ast.Return:
		return_list+=recurse_type(Node.expr)
		

	elif typ == c_ast.Struct:
		for i in Node.decls:
			return_list+=recurse_type(i)
		
	
	elif typ == c_ast.StructRef:
		return_list+=recurse_type(Node.name)
		return_list+=recurse_type(Node.field)
		
	elif typ == c_ast.Switch:
		return_list+=recurse_type(Node.cond)
		return_list+=recurse_type(Node.stmt)


	elif typ == c_ast.TernaryOp:
		return_list+=recurse_type(Node.cond)
		return_list+=recurse_type(Node.iftrue)
		return_list+=recurse_type(Node.iffalse)

	
	elif typ == c_ast.TypeDecl:
		return_list+=recurse_type(Node.type)
		
	elif typ == c_ast.Typedef:
		return_list+=recurse_type(Node.type)
		
	elif typ == c_ast.Typename:
		return_list+=recurse_type(Node.type)

	elif typ == c_ast.UnaryOp:
		return_list+=recurse_type(Node.expr)


	elif typ == c_ast.Union:
		for i in Node.decls:
			return_list+=recurse_type(i)
	
	elif typ == c_ast.While:
		return_list+=recurse_type(Node.cond)
		return_list+=recurse_type(Node.stmt)

	return return_list



if __name__ == "__main__":
    if len(sys.argv) > 1:
        c_decl  = sys.argv[1]
    else:
        c_decl = "char *(*(**foo[][8])())[];"

    print("Explaining the declaration: " + c_decl + "\n")
    print(explain_c_declaration(c_decl) + "\n") 

